<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.31.0">
    <meta name="project" content="Anoma v0.18.0">


    <title>Anoma.Node.Storage â€” Anoma v0.18.0</title>
    <link rel="stylesheet" href="dist/html-elixir-3ZLIM5JF.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-43PMFBC7.js"></script>
    <script src="dist/sidebar_items-703F6B39.js"></script>

      <script src="./.doc-versions.js"></script>

    <script async src="dist/html-CILPWI2Q.js"></script>


  </head>
  <body data-type="modules" class="page-module">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

      <div>
        <a href="readme.html" class="sidebar-projectName" translate="no">
Anoma
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v0.18.0
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
GUIDES
        </button>
      </li>

        <li>
          <button id="modules-list-tab-button" role="tab" data-type="modules" aria-controls="modules-tab-panel" aria-selected="false" tabindex="-1">
            Modules
          </button>
        </li>


        <li>
          <button id="tasks-list-tab-button" role="tab" data-type="tasks" aria-controls="tasks-tab-panel" aria-selected="false" tabindex="-1">
            <span translate="no">Mix</span> Tasks
          </button>
        </li>

    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>

    <div id="modules-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="modules-list-tab-button" hidden>
      <ul id="modules-full-list" class="full-list"></ul>
    </div>


    <div id="tasks-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="tasks-list-tab-button" hidden>
      <ul id="tasks-full-list" class="full-list"></ul>
    </div>

</nav>

<main class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">
      <div class="top-search">
        <div class="search-settings">
          <form class="search-bar" action="search.html">
            <label class="search-label">
              <span class="sr-only">Search documentation of Anoma</span>
              <input name="q" type="text" class="search-input" placeholder="Search Documentation (press /)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
            </label>
            <button type="submit" class="search-button" aria-label="Submit Search">
              <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
            </button>
            <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
              <i class="ri-close-line ri-lg" title="Cancel search"></i>
            </button>
          </form>
          <button class="icon-settings display-settings">
            <i class="ri-settings-3-line"></i>
            <span class="sr-only">Settings</span>
          </button>
        </div>
      </div>
      <div class="autocomplete">
      </div>

<h1>

  <span translate="no">Anoma.Node.Storage</span> 
  <small class="app-vsn" translate="no">(Anoma v0.18.0)</small>

</h1>


  <section id="moduledoc">
<p>I am the Anoma Storage Engine.</p><p>The Anoma database usage is separated into two parts:</p><ol><li><p>The Ordering table provides info on the order of appropriate keys.
That is, it has info about how many times the key has been assigned to
some value.</p></li><li><p>The Qualified table provides a representation of all stored key-values
in a particular format. Each entry has inside it</p><ol><li>The table name attached</li><li>The order of the key given by the Ordering</li><li>The namespace idenifying the Storage Engine</li><li>The key itself as provided by the user.</li></ol></li></ol><p>As a Storage Engine, I provide the appropriate functionality
to coordinate the Ordering and Qualified tables of a launched Anoma Node.</p><p>That is, I help with writing things respecting the ordering of events
while providing appropriate reading capabilities of the tables used, so
that the base read events read only the latest value of a given key.</p><h3 id="module-public-api" class="section-heading">
  <a href="#module-public-api" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Public API</span>
</h3>
<p>I provide the following public functionality:</p><h4>Setup</h4><ul><li><a href="#setup/1"><code class="inline">setup/1</code></a></li><li><a href="#remove/1"><code class="inline">remove/1</code></a></li><li><a href="#do_setup/1"><code class="inline">do_setup/1</code></a></li><li><a href="#ensure_new/2"><code class="inline">ensure_new/2</code></a></li><li><a href="#do_ensure_new/2"><code class="inline">do_ensure_new/2</code></a></li></ul><h4>Writing</h4><ul><li><a href="#put_snapshot/2"><code class="inline">put_snapshot/2</code></a></li><li><a href="#delete_key/2"><code class="inline">delete_key/2</code></a></li><li><a href="#put/3"><code class="inline">put/3</code></a></li></ul><h4>Reading</h4><ul><li><a href="#snapshot_order/1"><code class="inline">snapshot_order/1</code></a></li><li><a href="#get/2"><code class="inline">get/2</code></a></li><li><a href="#get_keyspace/2"><code class="inline">get_keyspace/2</code></a></li><li><a href="#get_at_snapshot/2"><code class="inline">get_at_snapshot/2</code></a></li><li><a href="#in_snapshot/2"><code class="inline">in_snapshot/2</code></a></li><li><a href="#read_order/2"><code class="inline">read_order/2</code></a></li><li><a href="#read_order_tx/2"><code class="inline">read_order_tx/2</code></a></li><li><a href="#read_at_order/3"><code class="inline">read_at_order/3</code></a></li><li><a href="#read_at_order_tx/3"><code class="inline">read_at_order_tx/3</code></a></li></ul><h4>Blocking</h4><ul><li><a href="#blocking_read/2"><code class="inline">blocking_read/2</code></a></li></ul><h4>Other</h4><ul><li><code class="inline">cm_tree_spec/0</code></li></ul>
  </section>


  <section id="summary" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#summary">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Summary</span>
    </h1>
<div class="summary-types summary">
  <h2>
    <a href="#types">Types</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:order_key/0" translate="no">order_key()</a>

      </div>

        <div class="summary-synopsis"><p>I designate the type of keys for Ordering table queries.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:order_value/0" translate="no">order_value()</a>

      </div>

        <div class="summary-synopsis"><p>I designate the type of values of keys for Ordering table queries.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:qualified_key/0" translate="no">qualified_key()</a>

      </div>

        <div class="summary-synopsis"><p>I designate the type of keys for Qualified table queries.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:qualified_value/0" translate="no">qualified_value()</a>

      </div>

        <div class="summary-synopsis"><p>I designate the type of values of Keys for Qualified table queries.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:result/1" translate="no">result(res)</a>

      </div>

        <div class="summary-synopsis"><p>I am the type of a mensia table query result.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:snapshot/0" translate="no">snapshot()</a>

      </div>

        <div class="summary-synopsis"><p>I designate the snapshot type for table queries.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:t/0" translate="no">t()</a>

      </div>

        <div class="summary-synopsis"><p>I am the type of the Storage Engine.</p></div>

    </div>

</div>
<div class="summary-functions summary">
  <h2>
    <a href="#functions">Functions</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#blocking_read/2" translate="no">blocking_read(storage, key)</a>

      </div>

        <div class="summary-synopsis"><p>I provide the final part of the blocking functionality for the Worker
necessary for transaction-execution.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#child_spec/1" translate="no">child_spec(init_arg)</a>

      </div>

        <div class="summary-synopsis"><p>Returns a specification to start this module under a supervisor.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#delete_key/2" translate="no">delete_key(storage, key)</a>

      </div>

        <div class="summary-synopsis"><p>I provide the main tombstoning functionality for the Storage Engine.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#do_ensure_new/2" translate="no">do_ensure_new(storage, rocks \\ false)</a>

      </div>

        <div class="summary-synopsis"><p>I ensure that the fed in storage names correspond to completely empty new
tables.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#do_setup/2" translate="no">do_setup(t, rocks \\ false)</a>

      </div>

        <div class="summary-synopsis"><p>I setup storage with the given tables from the Storage Engine structure.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#ensure_new/2" translate="no">ensure_new(storage, rocks \\ false)</a>

      </div>

        <div class="summary-synopsis"><p>I am the function ensuring appropriate db functionality.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#get/2" translate="no">get(storage, key)</a>

      </div>

        <div class="summary-synopsis"><p>I am the main reading function for the Storage functionality.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#get_at_snapshot/2" translate="no">get_at_snapshot(snapshot, key)</a>

      </div>

        <div class="summary-synopsis"><p>I provide the main functionality of rescuing latest snapshot value of a
given key.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#get_keyspace/2" translate="no">get_keyspace(storage, key_space)</a>

      </div>

        <div class="summary-synopsis"><p>I am the keyspace reading function for the Storage Engine.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#handle_cast/3" translate="no">handle_cast(arg1, _, storage)</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#in_snapshot/2" translate="no">in_snapshot(arg, key)</a>

      </div>

        <div class="summary-synopsis"><p>I am the function searching for a key position inside of a given Ordering
snapshot.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#init/1" translate="no">init(state)</a>

      </div>

        <div class="summary-synopsis"><p>I am the initialization function for a Storage Engine Instance.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#put/3" translate="no">put(storage, key, value)</a>

      </div>

        <div class="summary-synopsis"><p>I provide the main writing functionality of the Storage Engine.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#put_snapshot/2" translate="no">put_snapshot(storage, key)</a>

      </div>

        <div class="summary-synopsis"><p>I am the function responsible for writing an Ordering snapshot to our db.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#read_at_order/3" translate="no">read_at_order(storage, key, order)</a>

      </div>

        <div class="summary-synopsis"><p>I am the read_at_order function.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#read_at_order_tx/3" translate="no">read_at_order_tx(storage, key, order)</a>

      </div>

        <div class="summary-synopsis"><p>I am the function getting the value of a key at a particular order.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#read_keyspace_order/2" translate="no">read_keyspace_order(storage, key_query)</a>

      </div>

        <div class="summary-synopsis"><p>I am the read_keyspace_order function.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#read_order/2" translate="no">read_order(storage, key)</a>

      </div>

        <div class="summary-synopsis"><p>I am the read_order function.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#read_order_tx/2" translate="no">read_order_tx(storage, key)</a>

      </div>

        <div class="summary-synopsis"><p>I am the main function for getting orders of keys.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#remove/1" translate="no">remove(storage)</a>

      </div>

        <div class="summary-synopsis"><p>I am the storage removal function.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#setup/1" translate="no">setup(t)</a>

      </div>

        <div class="summary-synopsis"><p>I am the setup function for Storage.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#snapshot_order/1" translate="no">snapshot_order(storage)</a>

      </div>

        <div class="summary-synopsis"><p>I provide a snapshotting functionality for the Ordering table.</p></div>

    </div>

</div>

  </section>


  <section id="types" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#types">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Types</span>
    </h1>
    <div class="types-list">
<section class="detail" id="t:order_key/0">

  <div class="detail-header">
    <a href="#t:order_key/0" class="detail-link" title="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature" translate="no">order_key()</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> order_key() :: <a href="Noun.html#t:t/0">Noun.t</a>()</pre>

      </div>

<p>I designate the type of keys for Ordering table queries.</p>
  </section>
</section>
<section class="detail" id="t:order_value/0">

  <div class="detail-header">
    <a href="#t:order_value/0" class="detail-link" title="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature" translate="no">order_value()</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> order_value() :: [{<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>(), <a href="Noun.html#t:t/0">Noun.t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()}]</pre>

      </div>

<p>I designate the type of values of keys for Ordering table queries.</p>
  </section>
</section>
<section class="detail" id="t:qualified_key/0">

  <div class="detail-header">
    <a href="#t:qualified_key/0" class="detail-link" title="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature" translate="no">qualified_key()</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> qualified_key() :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">nonempty_improper_list</a>(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>())</pre>

      </div>

<p>I designate the type of keys for Qualified table queries.</p>
  </section>
</section>
<section class="detail" id="t:qualified_value/0">

  <div class="detail-header">
    <a href="#t:qualified_value/0" class="detail-link" title="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature" translate="no">qualified_value()</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> qualified_value() :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()</pre>

      </div>

<p>I designate the type of values of Keys for Qualified table queries.</p>
  </section>
</section>
<section class="detail" id="t:result/1">

  <div class="detail-header">
    <a href="#t:result/1" class="detail-link" title="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature" translate="no">result(res)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> result(res) :: {:atomic, res} | {:aborted, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()}</pre>

      </div>

<p>I am the type of a mensia table query result.</p>
  </section>
</section>
<section class="detail" id="t:snapshot/0">

  <div class="detail-header">
    <a href="#t:snapshot/0" class="detail-link" title="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature" translate="no">snapshot()</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> snapshot() :: {<a href="#t:t/0">t</a>(), [{<a href="#t:order_key/0">order_key</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()}]}</pre>

      </div>

<p>I designate the snapshot type for table queries.</p>
  </section>
</section>
<section class="detail" id="t:t/0">

  <div class="detail-header">
    <a href="#t:t/0" class="detail-link" title="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature" translate="no">t()</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> t() :: %Anoma.Node.Storage{
  namespace: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()],
  order: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  qualified: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  rm_commitments: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  topic: <a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>() | nil
}</pre>

      </div>

<p>I am the type of the Storage Engine.</p><p>I store info on the db tables used by the Node and info for appropriate
read/write actions.</p><h3 id="t:t/0-fields" class="section-heading">
  <a href="#t:t/0-fields" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Fields</span>
</h3>
<ul><li><code class="inline">:qualified</code> - The name of the Qualified table.<pre><code class="makeup elixir" translate="no"><span class="w">           </span><span class="ss">Default</span><span class="p">:</span><span class="w"> </span><span class="nc">Anoma.Node.Storage.Qualified</span></code></pre></li><li><code class="inline">:order</code> - The name of the Ordering table.<pre><code class="makeup elixir" translate="no"><span class="w">       </span><span class="ss">Default</span><span class="p">:</span><span class="w"> </span><span class="nc">Anoma.Node.Storage.Order</span></code></pre></li><li><code class="inline">:rm_commitments</code> - The name of the Reource Machine Commitments table.<pre><code class="makeup elixir" translate="no"><span class="w">                </span><span class="ss">Default</span><span class="p">:</span><span class="w"> </span><span class="nc">Anoma.Node.Storage.RMCommitments</span></code></pre></li><li><code class="inline">:namespace</code> - The namespace used for writing functionality.<pre><code class="makeup elixir" translate="no"><span class="w">           </span><span class="ss">Default</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2430364811-1">[</span><span class="p" data-group-id="2430364811-1">]</span></code></pre></li><li><code class="inline">:topic</code> - The subscription topic.<pre><code class="makeup elixir" translate="no"><span class="w">       </span><span class="ss">Enforced</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre></li></ul>
  </section>
</section>

    </div>
  </section>

  <section id="functions" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#functions">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Functions</span>
    </h1>
    <div class="functions-list">
<section class="detail" id="blocking_read/2">

  <div class="detail-header">
    <a href="#blocking_read/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">blocking_read(storage, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> blocking_read(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), <a href="#t:qualified_key/0">qualified_key</a>()) ::
  :error | {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()}</pre>

      </div>

<p>I provide the final part of the blocking functionality for the Worker
necessary for transaction-execution.</p><h3 id="blocking_read/2-general-usage" class="section-heading">
  <a href="#blocking_read/2-general-usage" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">General Usage</span>
</h3>
<p>I expect a Storage Engine address alingside with a key. Given a key which
isn't a list, I error. Given a key which is a list starting with 0, I
error following Nock and Ordering semantics. Given any other list, I
subscribe to a Qualified table that is attached to the given Storage and
read it in the Qualified table.</p><p>If the key has a non-empty value in the table, I return <code class="inline">{:ok, value}</code>
and unsubscribe from the table.</p><p>If the key does not have a value in the table, I wait until I receive a
<code class="inline">:write</code> message from the table, where the key written is exactlythe key
supplied. Given the message, I return the written value as <code class="inline">{:ok, value}</code>
and unsubscribe from the table.</p><h3 id="blocking_read/2-anoma-intended-semantics" class="section-heading">
  <a href="#blocking_read/2-anoma-intended-semantics" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Anoma-Intended Semantics</span>
</h3>
<p>My intended use in the Anoma Lifecycle is as follows:</p><p>I am called by the Worker after assigning its transaction ID to the order
assigned for block-generation. The key here is given as a cell of form
[n | snapshot_path] where <code class="inline">n</code> is a natural number representing the <code class="inline">n</code>-th
transaction candidate - i.e. the order of the transaction the Worker is
occupied with - and snapshot_path is a Nock list, i.e. an improper list
of form <code class="inline">[... | 0]</code>.</p><p>My main functionality is to make sure that the value of said transaction
has been recorded suscessfully in the Qualified table in the following
way:</p><p>After subscribing to the appropriate Qualified table, I first check the
fed-in Nock noun. If it starts with 0, I produce <code class="inline">:error</code>, per standard
semantics. Given another Nock cell, we then read it as a key inside our
Qualified table. If the value has already been written, we return it as
an <code class="inline">{:ok, value}</code> tuple.</p><p>Otherwise, if we read-off an empty list, i.e. if the appropriate
transaction value has not been written, we wait for the message that the
exact key has been written with some value in the table. Then we return
the value written in an <code class="inline">{:ok, value}</code> tuple.</p>
  </section>
</section>
<section class="detail" id="child_spec/1">

  <div class="detail-header">
    <a href="#child_spec/1" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">child_spec(init_arg)</h1>


  </div>

  <section class="docstring">

<p>Returns a specification to start this module under a supervisor.</p><p>See <a href="https://hexdocs.pm/elixir/Supervisor.html"><code class="inline">Supervisor</code></a>.</p>
  </section>
</section>
<section class="detail" id="delete_key/2">

  <div class="detail-header">
    <a href="#delete_key/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">delete_key(storage, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> delete_key(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), <a href="#t:order_key/0">order_key</a>()) :: :ok</pre>

      </div>

<p>I provide the main tombstoning functionality for the Storage Engine.</p><p>My main goal is to provide the API to make a key indistinguishable from
being absent in the underlying table. That is, I use <a href="#put/3"><code class="inline">put/3</code></a> to make the
latest key value <code class="inline">:absent</code>. This way, I make it impossible to distinguish
between the given key never been put into the Qualified table and being
deleted using the main <a href="#get/2"><code class="inline">get/2</code></a> functionality.</p>
  </section>
</section>
<section class="detail" id="do_ensure_new/2">

    <span id="do_ensure_new/1"></span>

  <div class="detail-header">
    <a href="#do_ensure_new/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">do_ensure_new(storage, rocks \\ false)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> do_ensure_new(<a href="#t:t/0">t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">boolean</a>()) :: :ok | {:aborted, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()}</pre>

      </div>

<p>I ensure that the fed in storage names correspond to completely empty new
tables.</p><p>I first delete all tables as specified in the Storage Engine structure,
afterwards creating the tables with given names using <a href="#do_setup/2"><code class="inline">do_setup/2</code></a>.</p>
  </section>
</section>
<section class="detail" id="do_setup/2">

    <span id="do_setup/1"></span>

  <div class="detail-header">
    <a href="#do_setup/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">do_setup(t, rocks \\ false)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> do_setup(<a href="#t:t/0">t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">boolean</a>()) :: :ok | {:aborted, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()}</pre>

      </div>

<p>I setup storage with the given tables from the Storage Engine structure.</p><p>I will try to create all values of storage, even if the first one fails
due to already being created, we will try the others, setting them using
rocksdb depending on the second argument given in the argument.</p>
  </section>
</section>
<section class="detail" id="ensure_new/2">

    <span id="ensure_new/1"></span>

  <div class="detail-header">
    <a href="#ensure_new/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">ensure_new(storage, rocks \\ false)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> ensure_new(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">boolean</a>()) :: :ok</pre>

      </div>

<p>I am the function ensuring appropriate db functionality.</p><p>Given a Storage address and a boolean flag, I first use <a href="#remove/1"><code class="inline">remove/1</code></a>
functionality to delete specified tables of the Engine and then
ask for a setup using <a href="#setup/1"><code class="inline">setup/1</code></a> functionality with an appropriate flag
for rocksdb copies.</p>
  </section>
</section>
<section class="detail" id="get/2">

  <div class="detail-header">
    <a href="#get/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">get(storage, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> get(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), <a href="#t:order_key/0">order_key</a>()) ::
  :absent | {:ok, <a href="#t:qualified_value/0">qualified_value</a>()} | {:error, :timed_out}</pre>

      </div>

<p>I am the main reading function for the Storage functionality.</p><p>Given a storage address and key name in the Order format, I look up the
latest value of such a key in the Qualified storage and return it in the
standard mnesia format. Otherwise, I return <code class="inline">:absent</code> if no value is
present (or if the key is tombstoned* in the latest instance).</p><p>See <a href="#delete_key/2"><code class="inline">delete_key/2</code></a></p>
  </section>
</section>
<section class="detail" id="get_at_snapshot/2">

  <div class="detail-header">
    <a href="#get_at_snapshot/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">get_at_snapshot(snapshot, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> get_at_snapshot(<a href="#t:snapshot/0">snapshot</a>(), <a href="#t:order_key/0">order_key</a>()) :: :absent | {:ok, <a href="#t:qualified_value/0">qualified_value</a>()}</pre>

      </div>

<p>I provide the main functionality of rescuing latest snapshot value of a
given key.</p><p>Given a {storage, snapshot} pair and a key, I search for the order of the
key as captured by the snapshot using <a href="#in_snapshot/2"><code class="inline">in_snapshot/2</code></a>. Afterwards, I
check the value of said key in said position in the provided table,
returning said value in the standard mnesia format.</p>
  </section>
</section>
<section class="detail" id="get_keyspace/2">

  <div class="detail-header">
    <a href="#get_keyspace/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">get_keyspace(storage, key_space)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> get_keyspace(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), [<a href="#t:order_key/0">order_key</a>()]) ::
  :absent | [{<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>(), <a href="#t:qualified_value/0">qualified_value</a>()}] | {:atomic, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()}</pre>

      </div>

<p>I am the keyspace reading function for the Storage Engine.</p><p>Given a storage address and a list of keys in the appropriate format, I
first look up whether the keys appear in any qualified key in the
Qualified table. If so, look up all apropriate latest values of all such
keys and return them as a list of table query responses in a standard
mnesia format. If not present, return <code class="inline">:absent</code></p>
  </section>
</section>
<section class="detail" id="handle_cast/3">

  <div class="detail-header">
    <a href="#handle_cast/3" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">handle_cast(arg1, _, storage)</h1>


  </div>

  <section class="docstring">


  </section>
</section>
<section class="detail" id="in_snapshot/2">

  <div class="detail-header">
    <a href="#in_snapshot/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">in_snapshot(arg, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> in_snapshot(<a href="#t:snapshot/0">snapshot</a>(), <a href="#t:order_key/0">order_key</a>()) :: nil | <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()</pre>

      </div>

<p>I am the function searching for a key position inside of a given Ordering
snapshot.</p><p>Given a {key, snapshot} tuple I go though the snapshot searching for the
key in the format we store it inside the tables (i.e. namespaced). After
which, I return the stored value, i.e. the latest Order at the point of
snapshot-taking.</p>
  </section>
</section>
<section class="detail" id="init/1">

  <div class="detail-header">
    <a href="#init/1" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">init(state)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> init(<a href="#t:t/0">t</a>()) :: {:ok, <a href="#t:t/0">t</a>()}</pre>

          <pre translate="no"><span class="attribute">@spec</span> init(
  [
    qualified: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
    order: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
    rm_commitments: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
    namespace: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()],
    topic: <a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>()
  ]
  | %{
      qualified: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
      order: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
      rm_commitments: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
      namespace: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()],
      topic: <a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>()
    }
) :: {:ok, <a href="#t:t/0">t</a>()}</pre>

      </div>

<p>I am the initialization function for a Storage Engine Instance.</p><h3 id="init/1-pattern-macthing-variations" class="section-heading">
  <a href="#init/1-pattern-macthing-variations" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Pattern-Macthing Variations</span>
</h3>
<ul><li><code class="inline">init(%Storage{})</code> - I initialize the Engine with the given state.</li><li><code class="inline">init(args)</code> - I expect a keylist/map with all the keywords matching<pre><code class="makeup elixir" translate="no"><span class="w">           </span><span class="n">the</span><span class="w"> </span><span class="nc">Storage</span><span class="w"> </span><span class="nc">Engine</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">fields</span><span class="o">.</span><span class="w"> </span><span class="nc">I</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">setup</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">tables</span><span class="w">
           </span><span class="ow">and</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">appropriate</span><span class="w"> </span><span class="nc">Engine</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">startup</span><span class="o">.</span></code></pre></li></ul>
  </section>
</section>
<section class="detail" id="put/3">

  <div class="detail-header">
    <a href="#put/3" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">put(storage, key, value)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> put(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), <a href="#t:order_key/0">order_key</a>(), <a href="#t:qualified_value/0">qualified_value</a>()) :: :ok</pre>

      </div>

<p>I provide the main writing functionality of the Storage Engine.</p><p>I am responsible for assigning the given values to key while respecting
the underlying table structure.</p><p>That is, given a key and a value, I first namespace the key getting the
namespace info from the appropriate storage state. Secondly, I re-write
the order-value assigned to said namespaced key, incrementing its value.
Finally, I write the value given to me to the Qualified table, assigning
it to the namspaced key with appropriate new order attached,
corresponding to the one in the Ordering table.</p>
  </section>
</section>
<section class="detail" id="put_snapshot/2">

  <div class="detail-header">
    <a href="#put_snapshot/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">put_snapshot(storage, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> put_snapshot(<a href="Anoma.Node.Router.html#t:addr/0">Anoma.Node.Router.addr</a>(), <a href="#t:order_key/0">order_key</a>()) :: :ok</pre>

      </div>

<p>I am the function responsible for writing an Ordering snapshot to our db.</p><p>Given a Storage Address and a key, I first snapshot the appropriate
Ordering table - similarly to <a href="#snapshot_order/1"><code class="inline">snapshot_order/1</code></a> - and then put it using
the functionality underlying <a href="#put/3"><code class="inline">put/3</code></a> as a value for the supplied key.</p><p>Consult <a href="#put/3"><code class="inline">put/3</code></a> on the exact mechanism behind our writing.</p>
  </section>
</section>
<section class="detail" id="read_at_order/3">

  <div class="detail-header">
    <a href="#read_at_order/3" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">read_at_order(storage, key, order)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> read_at_order(<a href="#t:t/0">t</a>(), <a href="Noun.html#t:t/0">Noun.t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()) :: [
  {<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(), <a href="#t:qualified_key/0">qualified_key</a>(), <a href="#t:qualified_value/0">qualified_value</a>()}
]</pre>

      </div>

<p>I am the read_at_order function.</p><p>I provide detailed reading functionality for the qualified table. Given a
storage structure, a key, and an order, I read the Qualified mnesia table
at a value which on a high-level corresponds to reading the key value at
that particular order, which is, of course, represented by the order
being part of the searched key at the mnesia level.</p><p>I return a list of 3-tuples with elements:</p><ol><li>Name of Qualified Table</li><li>Key (note here &quot;key&quot; has different semantics than top-level API as<pre><code class="makeup elixir" translate="no"><span class="w"> </span><span class="n">noted</span><span class="w"> </span><span class="n">above</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">lot</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">extra</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">order</span><span class="p">)</span></code></pre></li><li>Value of the key</li></ol>
  </section>
</section>
<section class="detail" id="read_at_order_tx/3">

  <div class="detail-header">
    <a href="#read_at_order_tx/3" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">read_at_order_tx(storage, key, order)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> read_at_order_tx(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), <a href="Noun.html#t:t/0">Noun.t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()) ::
  <a href="#t:result/1">result</a>([{<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(), <a href="#t:qualified_key/0">qualified_key</a>(), <a href="#t:qualified_value/0">qualified_value</a>()}])</pre>

      </div>

<p>I am the function getting the value of a key at a particular order.</p><p>My main role is to get transactions at the order given by the Ordering
Engine. Generally, the user is to inquire about the value of a key using
<a href="#get/2"><code class="inline">get/2</code></a> functionality.</p><p>Given a Storage address, a key, and the order, I return the list
containing the name of the storage, the key as given in the inputs, and
its value at the specified order in the traditional mnesia format using
<code class="inline">:mnesia.transaction</code> capabilities.</p><p>See <a href="#read_at_order/3"><code class="inline">read_at_order/3</code></a> for how we actually read the value from the
Qualified table.</p>
  </section>
</section>
<section class="detail" id="read_keyspace_order/2">

  <div class="detail-header">
    <a href="#read_keyspace_order/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">read_keyspace_order(storage, key_query)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> read_keyspace_order(<a href="#t:t/0">t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) :: <a href="#t:result/1">result</a>([[<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()]])</pre>

      </div>

<p>I am the read_keyspace_order function.</p><p>My functionality is very similar to <a href="#read_order/2"><code class="inline">read_order/2</code></a> yet instead of using
the mnesia <code class="inline">read</code> I use <code class="inline">select</code> and pick out any keys of list type in
the Ordering table which might contain inside the given keylist.</p><p>I return the <code class="inline">{:atomic, lst}</code> tuple where the latter value is a list of
lists where the head are the denamespaced keys containing our original
query keylist and the tail being the order.</p>
  </section>
</section>
<section class="detail" id="read_order/2">

  <div class="detail-header">
    <a href="#read_order/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">read_order(storage, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> read_order(<a href="#t:t/0">t</a>(), <a href="#t:order_key/0">order_key</a>()) :: [{<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(), <a href="Noun.html#t:t/0">Noun.t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()}]</pre>

      </div>

<p>I am the read_order function.</p><p>Given a storage structure and a key, I read the order of said key
by literally asking mnesia to read the Ordering table at the key which
is gotten by appending the storage namespace to the initially given key.</p><p>I return a list of three-tuples with following elements:</p><ol><li>Ordering table name</li><li>Key</li><li>Order number</li></ol>
  </section>
</section>
<section class="detail" id="read_order_tx/2">

  <div class="detail-header">
    <a href="#read_order_tx/2" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">read_order_tx(storage, key)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> read_order_tx(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>(), <a href="#t:order_key/0">order_key</a>()) :: <a href="#t:result/1">result</a>(<a href="#t:order_value/0">order_value</a>())</pre>

      </div>

<p>I am the main function for getting orders of keys.</p><p>Given a Storage address and a key, I return the key with its specified
order in the Ordering table Storage using <code class="inline">:mnesia.transaction</code> to get
the value in standard mnesia format.</p><p>See <a href="#read_order/2"><code class="inline">read_order/2</code></a> for the exact mechanism behind order-reading.</p>
  </section>
</section>
<section class="detail" id="remove/1">

  <div class="detail-header">
    <a href="#remove/1" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">remove(storage)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> remove(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>()) :: :ok</pre>

      </div>

<p>I am the storage removal function.</p><p>Given a Storage Engine address, I ask mnesia to delete all tables found
inside said Engine structure.</p>
  </section>
</section>
<section class="detail" id="setup/1">

  <div class="detail-header">
    <a href="#setup/1" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">setup(t)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> setup(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>()) :: :ok</pre>

      </div>

<p>I am the setup function for Storage.</p><p>Given a Storage address, I look for the tables inside its structure,
and then try to create all mnesia tables with the given names. On
success, I also create a new commitment tree.</p>
  </section>
</section>
<section class="detail" id="snapshot_order/1">

  <div class="detail-header">
    <a href="#snapshot_order/1" class="detail-link" title="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">snapshot_order(storage)</h1>


  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@spec</span> snapshot_order(<a href="Anoma.Node.Router.Addr.html#t:t/0">Anoma.Node.Router.Addr.t</a>()) :: <a href="#t:result/1">result</a>(<a href="#t:snapshot/0">snapshot</a>())</pre>

      </div>

<p>I provide a snapshotting functionality for the Ordering table.</p><p>Given a Storage address, I look up the Ordering table attached to the
Engine and provide a snapshot of it as a list of keys with their orders
returned in a mnesia result format and the attached storage structure.</p>
  </section>
</section>

    </div>
  </section>

      <footer class="footer">
        <p>

            <span class="line">
              <a href="https://hex.pm/packages/anoma/0.18.0" class="footer-hex-package">Hex Package</a>

              <a href="https://preview.hex.pm/preview/anoma/0.18.0">Hex Preview</a>

                (<a href="https://preview.hex.pm/preview/anoma/0.18.0/show/lib/anoma/node/storage.ex">current file</a>)

            </span>

          <span class="line">
            <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
              Search HexDocs
            </button>

              <a href="Anoma.epub" title="ePub version">
                Download ePub version
              </a>

          </span>
        </p>

        <p class="built-using">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.31.0) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</main>
</div>

<script src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
mermaid.initialize({
  startOnLoad: false,
  theme: document.body.className.includes("dark") ? "dark" : "default"
});
let id = 0;
for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
  const preEl = codeEl.parentElement;
  const graphDefinition = codeEl.textContent;
  const graphEl = document.createElement("div");
  const graphId = "mermaid-graph-" + id++;
  mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
    graphEl.innerHTML = svg;
    bindFunctions?.(graphEl);
    preEl.insertAdjacentElement("afterend", graphEl);
    preEl.remove();
  });
}
});
</script>
<script src="https://cdn.jsdelivr.net/npm/vega@5.20.2"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@5.1.1"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6.18.2"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
for (const codeEl of document.querySelectorAll("pre code.vega-lite")) {
  try {
    const preEl = codeEl.parentElement;
    const spec = JSON.parse(codeEl.textContent);
    const plotEl = document.createElement("div");
    preEl.insertAdjacentElement("afterend", plotEl);
    vegaEmbed(plotEl, spec);
    preEl.remove();
  } catch (error) {
    console.log("Failed to render Vega-Lite plot: " + error)
  }
}
});
</script>

  </body>
</html>
